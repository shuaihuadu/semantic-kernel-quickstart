// Copyright (c) Microsoft. All rights reserved.

using AIPlugins.AzureFunctions.Generator.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.SemanticKernel;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace AIPlugins.AzureFunctions.Generator;

[Generator]
public class SemanticFunctionGenerator : ISourceGenerator
{
    private const string DefaultFunctionNamespace = "AiPlugin.Plugins";
    private const string FunctionConfigFileName = "config.json";
    private const string FunctionPromptFileName = "skprompt.txt";

    public void Execute(GeneratorExecutionContext context)
    {
        string? rootNamespace = context.GetRootNamespace();

        if (string.IsNullOrEmpty(rootNamespace))
        {
            rootNamespace = DefaultFunctionNamespace;
        }

        IEnumerable<AdditionalText> functionFiles = context.AdditionalFiles.Where(f =>
        f.Path.Contains(FunctionConfigFileName) ||
        f.Path.Contains(FunctionPromptFileName));

        //获取所有Build Action属性设置为C# analyzer additional file的文件，并按照其所在的目录进行分组
        IEnumerable<IGrouping<string, AdditionalText>> functionFileGroups = functionFiles.GroupBy(f => Path.GetDirectoryName(f.Path));

        //再按照具体的插件进行分组，获取Function所属的Plugin的目录，譬如：Plugins目录下面有APlugin、BPlugin，此处获取的是以APlugin和BPlugin为Key的分组结果
        IEnumerable<IGrouping<string, IGrouping<string, AdditionalText>>> pluginFolderGroups = functionFileGroups.GroupBy(f => Path.GetFileName(Path.GetDirectoryName(f.Key)));

        foreach (var pluginFolder in pluginFolderGroups)
        {
            string pluginName = pluginFolder.Key!;

            string classSource = GenerateClassSource(rootNamespace!, pluginName, pluginFolder!);

            context.AddSource(pluginName, SourceText.From(classSource, Encoding.UTF8));
        }
    }

    private string GenerateClassSource(string rootNamespace, string pluginName, IGrouping<string, IGrouping<string, AdditionalText>> functionGroups)
    {
        StringBuilder functionsCode = new();

        foreach (var functionGroup in functionGroups)
        {

            string functionName = Path.GetFileName(functionGroups.Key);

            AdditionalText? promptFile = functionGroup.FirstOrDefault(f => Path.GetFileName(f.Path).Equals(FunctionPromptFileName, StringComparison.InvariantCultureIgnoreCase));
            AdditionalText? configFile = functionGroup.FirstOrDefault(f => Path.GetFileName(f.Path).Equals(FunctionConfigFileName, StringComparison.InvariantCultureIgnoreCase));

            if (promptFile != default && configFile != default)
            {
                string code = GenerateFunctionSource(promptFile, configFile) ?? string.Empty;
                functionsCode.AppendLine(code);
            }
        }

        return $@"// <auto-generated />
using AiPlugin.Runner;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Azure.Functions.Worker.Http;
using Microsoft.Azure.WebJobs.Extensions.OpenApi.Core.Attributes;
using Microsoft.Extensions.Logging;
using Microsoft.OpenApi.Models;
using System.Net;

namespace {rootNamespace};

public class {pluginName}
{{
    private readonly ILogger _logger;
    private readonly IAiPluginRunner _pluginRunner;

    public {pluginName}(ILoggerFactory loggerFactory, IAiPluginRunner pluginRunner)
    {{
        this._logger = loggerFactory.CreateLogger<{pluginName}>();
        this._pluginRunner = pluginRunner;
    }}

    {functionsCode}
}}";
    }

    private static string? GenerateFunctionSource(AdditionalText promptFile, AdditionalText configFile)
    {
        string? functionName = Path.GetFileName(Path.GetDirectoryName(promptFile.Path));

        if (string.IsNullOrWhiteSpace(functionName))
        {
            return null;
        }

        string? metadataJson = configFile.GetText()?.ToString();

        if (string.IsNullOrEmpty(metadataJson))
        {
            return null;
        }

        PromptTemplateConfig? promptTemplateConfig = JsonConvert.DeserializeObject<PromptTemplateConfig>(metadataJson!);

        if (promptTemplateConfig is null) { return null; }

        string descriptionProperty = string.IsNullOrWhiteSpace(promptTemplateConfig.Description) ? string.Empty : $@", Description = ""{promptTemplateConfig.Description}""";

        string parameterAttributes = GenerateParameterAttributesSource(promptTemplateConfig.InputVariables);

        return $@"
    [OpenApiOperation(operationId: ""{functionName}"", tags: new []{{ ""{functionName}"" }}{descriptionProperty})]{parameterAttributes}
    [OpenApiResponseWithBody(statusCode: HttpStatusCode.OK, contentType: ""text/plain"", bodyType: typeof(string), Description = ""The OK response"")]
    [Function(""{functionName}"")]
    public Task<HttpResponseData> {functionName}([HttpTrigger(AuthorizationLevel.Anonymous, ""post"")] HttpRequestData request)
    {{
        this._logger.LogInformation(""HTTP trigger processed a request for function {functionName}."");

        return this._pluginRunner.RunAIPluginOperationAsync(request,""{functionName}"");
    }}";
    }

    private static string GenerateParameterAttributesSource(List<InputVariable> inputVariables)
    {
        StringBuilder parameterStringBuilder = new();

        if (inputVariables != null)
        {
            foreach (InputVariable inputVariable in inputVariables)
            {
                parameterStringBuilder.AppendLine();
                parameterStringBuilder.Append($@"    [OpenApiParameter(name: ""{inputVariable.Name}""");

                if (!string.IsNullOrWhiteSpace(inputVariable.Description))
                {
                    parameterStringBuilder.Append($@", Description = ""{inputVariable.Description}""");
                }

                parameterStringBuilder.Append(", In = ParameterLocation.Query");
                parameterStringBuilder.Append(", Type = typeof(string))]");
            }
        }

        return parameterStringBuilder.ToString();
    }

    public void Initialize(GeneratorInitializationContext context) { }
}
